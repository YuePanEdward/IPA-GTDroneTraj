function [tran_mat, Cov_mat, status] = coor_sys_tran_4dof(source, target)
% coor_sys_tran Function estimate the 4DOF transformation
% from two point cloud (source to target) with pre-determined correspondence
% the roll and pitch angle are fixed to 0
% input: source [n * 3] vector, target [n * 3] vector
% output: tran_mat [3 * 4] matrix, covariance matrix of the transforamtion estimation [6 * 6] matrix, status: 0 or 1

count_correspondence = size(source,1);

tz= mean(target(:,3)-source(:,3));
px_1 = source(1,1); py_1 = source(1,2);
px_2 = source(2,1); py_2 = source(2,2);
qx_1 = target(1,1); qy_1 = target(1,2);
qx_2 = target(2,1); qy_2 = target(2,2);

theta_0 = pi/4; % an initial guess
thre = 1e-6; 

while (1)

A_mat = [];
b_vec = [];
for i=1: count_correspondence
      
      A_mat = [A_mat;  
                     -sin(theta_0) * source(i,1) - cos(theta_0) * source(i,2) , 1 , 0;
                      cos(theta_0) * source(i,1)  - sin(theta_0) * source(i,2)  , 0 , 1];
       
      b_vec = [b_vec;
                     target(i,1)  - cos(theta_0) * source(i,1) + sin(theta_0) * source(i,2);
                     target(i,2)  - sin(theta_0)  * source(i,1) -  cos(theta_0)*source(i,2)];
                   
end
           
x_vec = inv(A_mat'*A_mat) * A_mat' * b_vec;
d_theta= x_vec(1);

theta_0 = theta_0 + d_theta;

if (abs(d_theta) < thre)
     break;
end
  
end           

tx = x_vec(2);
ty = x_vec(3);
theta = theta_0;

R_mat = [cos(theta), -sin(theta), 0;...
                sin(theta), cos(theta), 0;...
                0,0,1];
t_vec = [tx; ty; tz];

tran_mat = [R_mat,  t_vec];
               
p_tran_1 = R_mat *  source(1,:)' + t_vec;             
d_1 = norm(target(1,:)' -  p_tran_1);
p_tran_2 = R_mat *  source(2,:)' + t_vec;             
d_2 = norm(target(2,:)' -  p_tran_2);

disp('transform residual (m):');
d_1
d_2

status = 1;
d_thre = 0.05; % unit:m 
if((d_1+d_2)/2 > d_thre)
    status = 0; % problematic transformation
end 

% covariance matrix of the estimation:

% Trimble R8 GNSS (With SwiPos RTK service) accuracy: 8 mm Horizontal / 15 mm Vertical
rtk_std = [8e-3,8e-3,15e-3]; % unit: m
leveling_std = [1.0,1.0]; % roll, pitch, unit: angular second
%(make sure the leveling angle is as small as 1 second  by tuning the leveling bubble to locate it at the centre of the circle)
leveling_std = leveling_std/(190/pi*3600); % unit: rad 

res_vec = A_mat*x_vec - b_vec;
sigma2_posterior = 1/(2*count_correspondence-3) * res_vec' * res_vec;
Cov_x = sigma2_posterior*A_mat' * A_mat; % yaw, tx, ty
std2_tz = 1/count_correspondence * (rtk_std(3)^2;

Cov_mat = zeros(6);
Cov_mat(3:5, 3:5) = Cov_x;
Cov_mat(6,6) = std2_tz;
Cov_mat(1,1)=leveling_std(1)^2;
Cov_mat(2,2)=leveling_std(2)^2;

% convert from the sequence:  from (roll, pitch, yaw, x, y, z) to  (x,y,z,roll,pitch,yaw) 
Cov_mat_temp = Cov_mat;
Cov_mat_temp(1:3,1:3) = Cov_mat(4:6,4:6);
Cov_mat_temp(4:6,4:6) = Cov_mat(1:3,1:3);
Cov_mat_temp(1:3,4:6) = Cov_mat(4:6,1:3);
Cov_mat_temp(4:6,1:3) = Cov_mat(1:3,4:6);
Cov_mat = Cov_mat_temp; 

end
